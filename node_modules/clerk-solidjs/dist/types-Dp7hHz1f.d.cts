import { Clerk, InitialState, Without, ClerkOptions, ClientResource, MultiDomainAndOrProxy, DomainOrProxyUrl, LoadedClerk, SignInProps, SignOutOptions, SignUpProps, RedirectUrlProp, ClerkPaginatedResponse } from '@clerk/types';
import { JSX, Accessor, JSXElement } from 'solid-js';
import { ClerkAPIResponseError } from '@clerk/shared/error';

declare global {
    interface Window {
        __clerk_publishable_key?: string;
        __clerk_proxy_url?: Clerk['proxyUrl'];
        __clerk_domain?: Clerk['domain'];
    }
}
type IsomorphicClerkOptions = Without<ClerkOptions, 'isSatellite'> & {
    Clerk?: ClerkProp;
    /**
     * Define the URL that `@clerk/clerk-js` should be hot-loaded from
     */
    clerkJSUrl?: string;
    /**
     * If your web application only uses Control components, you can set this value to `'headless'` and load a minimal ClerkJS bundle for optimal page performance.
     */
    clerkJSVariant?: 'headless' | '';
    /**
     * Define the npm version for `@clerk/clerk-js`
     */
    clerkJSVersion?: string;
    /**
     * The Clerk publishable key for your instance
     * @note This can be found in your Clerk Dashboard on the [API Keys](https://dashboard.clerk.com/last-active?path=api-keys) page
     */
    publishableKey: string;
    /**
     * This nonce value will be passed through to the `@clerk/clerk-js` script tag.
     * @note You can use this to implement [strict-dynamic CSP](https://clerk.com/docs/security/clerk-csp#implementing-a-strict-dynamic-csp)
     */
    nonce?: string;
} & MultiDomainAndOrProxy;
type ClerkProviderProps = IsomorphicClerkOptions & {
    children: JSX.Element;
    initialState?: InitialState;
};
interface BrowserClerkConstructor {
    new (publishableKey: string, options?: DomainOrProxyUrl): BrowserClerk;
}
interface HeadlessBrowserClerkConstructor {
    new (publishableKey: string, options?: DomainOrProxyUrl): HeadlessBrowserClerk;
}
type WithClerkProp<T = unknown> = T & {
    clerk: Accessor<LoadedClerk>;
};
interface HeadlessBrowserClerk extends Clerk {
    load: (opts?: Without<ClerkOptions, 'isSatellite'>) => Promise<void>;
    updateClient: (client: ClientResource) => void;
}
interface BrowserClerk extends HeadlessBrowserClerk {
    onComponentsReady: Promise<void>;
    components: any;
}
type ClerkProp = BrowserClerkConstructor | BrowserClerk | HeadlessBrowserClerk | HeadlessBrowserClerkConstructor | undefined | null;
type ButtonProps = JSX.ButtonHTMLAttributes<HTMLButtonElement> & {
    mode?: 'redirect' | 'modal';
};
type SignInButtonProps = ButtonProps & Pick<SignInProps, 'fallbackRedirectUrl' | 'forceRedirectUrl' | 'signUpForceRedirectUrl' | 'signUpFallbackRedirectUrl'>;
type SignOutButtonProps = ButtonProps & Pick<SignOutOptions, 'redirectUrl' | 'sessionId'>;
type SignUpButtonProps = {
    unsafeMetadata?: SignUpUnsafeMetadata;
} & ButtonProps & Pick<SignUpProps, 'fallbackRedirectUrl' | 'forceRedirectUrl' | 'signInForceRedirectUrl' | 'signInFallbackRedirectUrl'>;
type SignInWithMetamaskButtonProps = ButtonProps & RedirectUrlProp;
type PageProps<T extends string> = {
    label: string;
    url: string;
    labelIcon: JSXElement;
} | {
    label: T;
    url?: never;
    labelIcon?: never;
};
type UserProfilePageProps = PageProps<'account' | 'security'>;
type UserProfileLinkProps = {
    url: string;
    label: string;
    labelIcon: JSXElement;
};
type OrganizationProfilePageProps = PageProps<'general' | 'members'>;
type OrganizationProfileLinkProps = UserProfileLinkProps;

type CacheSetter<CData = any> = (data?: CData | ((currentData?: CData) => Promise<undefined | CData> | undefined | CData)) => Promise<CData | undefined>;
type PaginatedResources<T = unknown, Infinite = false> = {
    data: () => T[];
    count: () => number;
    error: () => ClerkAPIResponseError | null;
    isLoading: () => boolean;
    isFetching: () => boolean;
    isError: () => boolean;
    page: () => number;
    pageCount: () => number;
    fetchPrevious: () => void;
    fetchNext: () => void;
    hasNextPage: () => boolean;
    hasPreviousPage: () => boolean;
    setData: Infinite extends true ? CacheSetter<(ClerkPaginatedResponse<T> | undefined)[]> : CacheSetter<ClerkPaginatedResponse<T> | undefined>;
    revalidate: () => Promise<void>;
};
type PaginatedHookConfig<T> = T & {
    /**
     * Persists the previous pages with new ones in the same array
     */
    infinite?: boolean;
    /**
     * Return the previous key's data until the new data has been loaded
     */
    keepPreviousData?: boolean;
};

export type { BrowserClerk as B, ClerkProviderProps as C, HeadlessBrowserClerk as H, IsomorphicClerkOptions as I, OrganizationProfilePageProps as O, PaginatedResources as P, SignInButtonProps as S, UserProfilePageProps as U, WithClerkProp as W, SignInWithMetamaskButtonProps as a, SignOutButtonProps as b, SignUpButtonProps as c, UserProfileLinkProps as d, OrganizationProfileLinkProps as e, PaginatedHookConfig as f, ClerkProp as g };
