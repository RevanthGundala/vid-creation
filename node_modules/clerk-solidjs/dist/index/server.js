import { normalizeWithDefaultValue, assertSingleChild, setErrorThrowerOptions, useAuthContext, useIsomorphicClerkContext, userProfilePageRenderedError, userProfileLinkRenderedError, organizationProfilePageRenderedError, organizationProfileLinkRenderedError, useClerkInstanceContext, useOrganizationContext, useSessionContext, useUserContext, useClientContext, ClerkInstanceContext, errorThrower, useAuthHasRequiresRoleOrPermission } from '../chunk/3ZJQ455L.js';
export { ClerkProvider } from '../chunk/3ZJQ455L.js';
import { ssrElement, escape, createComponent, mergeProps, ssr } from 'solid-js/web';
import { splitProps, createMemo, createEffect, children, Show, Switch, Match, createSignal, onMount, onCleanup, useContext } from 'solid-js';
import { logErrorInDevMode } from '@clerk/shared';
import { destructure } from '@solid-primitives/destructure';
import { eventMethodCalled } from '@clerk/shared/telemetry';
import { createWritableMemo } from '@solid-primitives/memo';
import { QueryClient, createQuery, createInfiniteQuery } from '@tanstack/solid-query';

// src/polyfills.ts
if (typeof window !== "undefined" && !window.global) {
  window.global = typeof global === "undefined" ? window : global;
}
function useAssertWrappedByClerkProvider(displayNameOrFn) {
  const ctx = useContext(ClerkInstanceContext);
  if (!ctx) {
    if (typeof displayNameOrFn === "function") {
      displayNameOrFn();
      return;
    }
    throw new Error(`${displayNameOrFn} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider`);
  }
}

// src/hooks/utils.ts
var clerkLoaded = (isomorphicClerk) => {
  return new Promise((resolve) => {
    const clerk = isomorphicClerk();
    if (clerk.loaded) {
      resolve();
    }
    clerk.addOnLoaded(resolve);
  });
};
var createGetToken = (isomorphicClerk) => {
  return async (options) => {
    const clerk = isomorphicClerk();
    await clerkLoaded(isomorphicClerk);
    if (!clerk.session) {
      return null;
    }
    return clerk.session.getToken(options);
  };
};
var createSignOut = (isomorphicClerk) => {
  return async (...args) => {
    await clerkLoaded(isomorphicClerk);
    return isomorphicClerk().signOut(...args);
  };
};

// src/hooks/use-auth.ts
var useAuth = () => {
  useAssertWrappedByClerkProvider("useAuth");
  const { sessionId, userId, actor, orgId, orgRole, orgPermissions } = useAuthContext();
  const isomorphicClerk = useIsomorphicClerkContext();
  const getToken = createGetToken(isomorphicClerk);
  const signOut = createSignOut(isomorphicClerk);
  const has = (params) => {
    if (!params?.permission && !params?.role) {
      errorThrower.throw(useAuthHasRequiresRoleOrPermission);
    }
    if (!orgId() || !userId() || !orgRole() || !orgPermissions()) {
      return false;
    }
    if (params.permission) {
      return orgPermissions().includes(params.permission);
    }
    if (params.role) {
      return orgRole() === params.role;
    }
    return false;
  };
  const isLoaded = createMemo(
    () => sessionId() !== undefined && userId() !== undefined
  );
  const isSignedIn = createMemo(() => {
    if (!isLoaded()) {
      return undefined;
    }
    return sessionId() !== null && userId() !== null;
  });
  return {
    isLoaded,
    isSignedIn,
    sessionId,
    userId,
    actor,
    orgId,
    orgRole,
    orgPermissions,
    has,
    signOut,
    getToken
  };
};
var withClerk = (Component, displayName) => {
  displayName = displayName || Component.name || "Component";
  return (props) => {
    useAssertWrappedByClerkProvider(displayName || "withClerk");
    const clerk = useIsomorphicClerkContext();
    const isLoaded = () => clerk().loaded;
    return createComponent(Show, {
      get when() {
        return isLoaded();
      },
      get children() {
        return createComponent(Component, mergeProps(props, {
          clerk
        }));
      }
    });
  };
};

// src/components/control-components.tsx
var SignedIn = (props) => {
  useAssertWrappedByClerkProvider("SignedIn");
  const {
    userId
  } = useAuthContext();
  return createComponent(Show, {
    get when() {
      return userId();
    },
    get children() {
      return props.children;
    }
  });
};
var SignedOut = (props) => {
  useAssertWrappedByClerkProvider("SignedOut");
  const {
    userId
  } = useAuthContext();
  return createComponent(Show, {
    get when() {
      return userId() === null;
    },
    get children() {
      return props.children;
    }
  });
};
var ClerkLoaded = (props) => {
  useAssertWrappedByClerkProvider("ClerkLoaded");
  const isomorphicClerk = useIsomorphicClerkContext();
  const isLoaded = () => isomorphicClerk().loaded;
  return createComponent(Show, {
    get when() {
      return isLoaded();
    },
    get children() {
      return props.children;
    }
  });
};
var ClerkLoading = (props) => {
  useAssertWrappedByClerkProvider("ClerkLoading");
  const isomorphicClerk = useIsomorphicClerkContext();
  const isLoaded = () => isomorphicClerk().loaded;
  return createComponent(Show, {
    get when() {
      return !isLoaded();
    },
    get children() {
      return props.children;
    }
  });
};
var Protect = (props) => {
  useAssertWrappedByClerkProvider("Protect");
  const [local, restAuthorizedParams] = splitProps(props, ["children", "fallback"]);
  const {
    isLoaded,
    has,
    userId
  } = useAuth();
  const unauthorized = local.fallback ?? null;
  const authorized = local.children;
  return createComponent(Switch, {
    fallback: unauthorized,
    get children() {
      return [createComponent(Match, {
        get when() {
          return !isLoaded();
        },
        children: unauthorized
      }), createComponent(Match, {
        get when() {
          return !userId();
        },
        children: unauthorized
      }), createComponent(Match, {
        get when() {
          return typeof restAuthorizedParams.condition === "function" && restAuthorizedParams.condition(has);
        },
        children: authorized
      }), createComponent(Match, {
        get when() {
          return (restAuthorizedParams.role || restAuthorizedParams.permission) && has(restAuthorizedParams);
        },
        children: authorized
      })];
    }
  });
};
var RedirectToSignIn = withClerk((props) => {
  const [local, redirectToSignInProps] = splitProps(props, ["clerk"]);
  const hasActiveSessions = createMemo(() => local.clerk().client.activeSessions && local.clerk().client.activeSessions.length > 0);
  createEffect(() => {
    if (local.clerk().session === null && hasActiveSessions()) {
      void local.clerk().redirectToAfterSignOut();
    } else {
      void local.clerk().redirectToSignIn(redirectToSignInProps);
    }
  });
  return null;
}, "RedirectToSignIn");
var RedirectToSignUp = withClerk((props) => {
  const [local, redirectToSignUpProps] = splitProps(props, ["clerk"]);
  createEffect(() => {
    void local.clerk().redirectToSignUp(redirectToSignUpProps);
  });
  return null;
}, "RedirectToSignUp");
var RedirectToUserProfile = withClerk((props) => {
  createEffect(() => {
    void props.clerk().redirectToUserProfile();
  });
  return null;
}, "RedirectToUserProfile");
var RedirectToOrganizationProfile = withClerk((props) => {
  createEffect(() => {
    void props.clerk().redirectToOrganizationProfile();
  });
  return null;
}, "RedirectToOrganizationProfile");
var RedirectToCreateOrganization = withClerk((props) => {
  createEffect(() => {
    void props.clerk().redirectToCreateOrganization();
  });
  return null;
}, "RedirectToCreateOrganization");
var AuthenticateWithRedirectCallback = withClerk((props) => {
  const [local, handleRedirectCallbackParams] = splitProps(props, ["clerk"]);
  createEffect(() => {
    void local.clerk().handleRedirectCallback(handleRedirectCallbackParams);
  });
  return null;
}, "AuthenticateWithRedirectCallback");
var SignInButton = withClerk((props) => {
  const [local, clerkProps, rest] = splitProps(props, ["children"], ["clerk", "signUpFallbackRedirectUrl", "signUpForceRedirectUrl", "forceRedirectUrl", "fallbackRedirectUrl", "mode", "onClick"]);
  const children2 = children(() => normalizeWithDefaultValue(local.children, "Sign in"));
  const child = createMemo(() => assertSingleChild(children2())("SignInButton"));
  return ssrElement("button", rest, escape(child()), false);
}, "SignInButton");
var SignInWithMetamaskButton = withClerk((props) => {
  const [local, clerkProps, rest] = splitProps(props, ["children"], ["clerk", "redirectUrl", "onClick"]);
  const children2 = children(() => normalizeWithDefaultValue(local.children, "Sign in with Metamask"));
  const child = createMemo(() => assertSingleChild(children2())("SignInWithMetamaskButton"));
  return ssrElement("button", rest, escape(child()), false);
}, "SignInWithMetamask");
var SignOutButton = withClerk((props) => {
  const [local, clerk, rest] = splitProps(props, ["children"], ["clerk", "redirectUrl", "sessionId", "onClick"]);
  const children2 = children(() => normalizeWithDefaultValue(local.children, "Sign out"));
  const child = createMemo(() => assertSingleChild(children2())("SignOutButton"));
  return ssrElement("button", rest, escape(child()), false);
}, "SignOutButton");
var SignUpButton = withClerk((props) => {
  const [local, clerkProps, rest] = splitProps(props, ["children"], ["clerk", "mode", "fallbackRedirectUrl", "forceRedirectUrl", "onClick"]);
  const children2 = children(() => normalizeWithDefaultValue(local.children, "Sign up"));
  const child = createMemo(() => assertSingleChild(children2())("SignUpButton"));
  return ssrElement("button", rest, escape(child()), false);
}, "SignUpButton");
var _tmpl$ = "<div></div>";
var isMountProps = (props) => {
  return "mount" in props;
};
var isOpenProps = (props) => {
  return "open" in props;
};
var Portal = (props) => {
  const [portalRef, setPortalRef] = createSignal();
  const componentProps = () => props.props;
  createEffect(() => {
    const ref = portalRef();
    if (ref && isMountProps(props)) {
      props.updateProps({
        node: ref,
        props: componentProps()
      });
    }
  });
  onMount(() => {
    const ref = portalRef();
    if (ref) {
      if (isMountProps(props)) {
        props.mount(ref, componentProps());
      } else if (isOpenProps(props)) {
        props.open(componentProps());
      }
    }
  });
  onCleanup(() => {
    const ref = portalRef();
    if (ref) {
      if (isMountProps(props)) {
        props.unmount(ref);
      } else if (isOpenProps(props)) {
        props.close();
      }
    }
  });
  return ssr(_tmpl$);
};
var SignIn = withClerk((props) => {
  const [local, rest] = splitProps(props, ["clerk"]);
  return createComponent(Portal, {
    get mount() {
      return local.clerk().mountSignIn;
    },
    get unmount() {
      return local.clerk().unmountSignIn;
    },
    get updateProps() {
      return local.clerk().__unstable__updateProps;
    },
    props: rest
  });
}, "SignIn");
var SignUp = withClerk((props) => {
  const [local, rest] = splitProps(props, ["clerk"]);
  return createComponent(Portal, {
    get mount() {
      return local.clerk().mountSignUp;
    },
    get unmount() {
      return local.clerk().unmountSignUp;
    },
    get updateProps() {
      return local.clerk().__unstable__updateProps;
    },
    props: rest
  });
}, "SignUp");
function UserProfilePage(props) {
  logErrorInDevMode(userProfilePageRenderedError);
  return children(() => props.children);
}
function UserProfileLink(props) {
  logErrorInDevMode(userProfileLinkRenderedError);
  return children(() => props.children);
}
var _UserProfile = withClerk((props) => {
  const [local, rest] = splitProps(props, ["clerk"]);
  return createComponent(Portal, {
    get mount() {
      return local.clerk().mountUserProfile;
    },
    get unmount() {
      return local.clerk().unmountUserProfile;
    },
    get updateProps() {
      return local.clerk().__unstable__updateProps;
    },
    props: rest
  });
}, "UserProfile");
var UserProfile = Object.assign(_UserProfile, {
  Page: UserProfilePage,
  Link: UserProfileLink
});
var _UserButton = withClerk((props) => {
  const [local, rest] = splitProps(props, ["clerk"]);
  return createComponent(Portal, {
    get mount() {
      return local.clerk().mountUserButton;
    },
    get unmount() {
      return local.clerk().unmountUserButton;
    },
    get updateProps() {
      return local.clerk().__unstable__updateProps;
    },
    props: rest
  });
}, "UserButton");
var UserButton = Object.assign(_UserButton, {
  UserProfilePage,
  UserProfileLink
});
function OrganizationProfilePage(props) {
  logErrorInDevMode(organizationProfilePageRenderedError);
  return children(() => props.children);
}
function OrganizationProfileLink(props) {
  logErrorInDevMode(organizationProfileLinkRenderedError);
  return children(() => props.children);
}
var _OrganizationProfile = withClerk((props) => {
  const [local, rest] = splitProps(props, ["clerk"]);
  return createComponent(Portal, {
    get mount() {
      return local.clerk().mountOrganizationProfile;
    },
    get unmount() {
      return local.clerk().unmountOrganizationProfile;
    },
    get updateProps() {
      return local.clerk().__unstable__updateProps;
    },
    props: rest
  });
}, "OrganizationProfile");
var OrganizationProfile = Object.assign(_OrganizationProfile, {
  Page: OrganizationProfilePage,
  Link: OrganizationProfileLink
});
var CreateOrganization = withClerk((props) => {
  const [local, rest] = splitProps(props, ["clerk"]);
  return createComponent(Portal, {
    get mount() {
      return local.clerk().mountCreateOrganization;
    },
    get unmount() {
      return local.clerk().unmountCreateOrganization;
    },
    get updateProps() {
      return local.clerk().__unstable__updateProps;
    },
    props: rest
  });
}, "CreateOrganization");
var _OrganizationSwitcher = withClerk((props) => {
  const [local, rest] = splitProps(props, ["clerk"]);
  return createComponent(Portal, {
    get mount() {
      return local.clerk().mountOrganizationSwitcher;
    },
    get unmount() {
      return local.clerk().unmountOrganizationSwitcher;
    },
    get updateProps() {
      return local.clerk().__unstable__updateProps;
    },
    props: rest
  });
}, "OrganizationSwitcher");
var OrganizationSwitcher = Object.assign(_OrganizationSwitcher, {
  OrganizationProfilePage,
  OrganizationProfileLink
});
var OrganizationList = withClerk((props) => {
  const [local, rest] = splitProps(props, ["clerk"]);
  return createComponent(Portal, {
    get mount() {
      return local.clerk().mountOrganizationList;
    },
    get unmount() {
      return local.clerk().unmountOrganizationList;
    },
    get updateProps() {
      return local.clerk().__unstable__updateProps;
    },
    props: rest
  });
}, "OrganizationList");
var GoogleOneTap = withClerk((props) => {
  const [local, rest] = splitProps(props, ["clerk"]);
  return createComponent(Portal, {
    get open() {
      return local.clerk().openGoogleOneTap;
    },
    get close() {
      return local.clerk().closeGoogleOneTap;
    },
    props: rest
  });
}, "GoogleOneTap");

// src/hooks/use-clerk.ts
var useClerk = () => {
  useAssertWrappedByClerkProvider("useClerk");
  return useClerkInstanceContext();
};
function useEmailLink(resource) {
  const linkFlows = createMemo(() => resource().createEmailLinkFlow());
  createEffect(() => {
    onCleanup(linkFlows().cancelEmailLinkFlow);
  });
  return destructure(linkFlows);
}
function getDifferentKeys(obj1, obj2) {
  const keysSet = new Set(Object.keys(obj2));
  const differentKeysObject = {};
  for (const key1 of Object.keys(obj1)) {
    if (!keysSet.has(key1)) {
      differentKeysObject[key1] = obj1[key1];
    }
  }
  return differentKeysObject;
}
var convertToSafeValues = (params, defaultValues) => {
  const shouldUseDefaults = typeof params === "boolean" && params;
  const initialPageRef = shouldUseDefaults ? defaultValues.initialPage : params?.initialPage ?? defaultValues.initialPage;
  const pageSizeRef = shouldUseDefaults ? defaultValues.pageSize : params?.pageSize ?? defaultValues.pageSize;
  const newObj = {};
  for (const key of Object.keys(defaultValues)) {
    newObj[key] = shouldUseDefaults ? (
      // @ts-ignore
      defaultValues[key]
    ) : (
      // @ts-ignore
      params?.[key] ?? defaultValues[key]
    );
  }
  return {
    ...newObj,
    initialPage: initialPageRef,
    pageSize: pageSizeRef
  };
};
var usePagesOrInfinite = (options) => {
  const [paginatedPage, setPaginatedPage] = createWritableMemo(
    () => options().params.initialPage ?? 1
  );
  const initialPage = createMemo(() => options().params.initialPage ?? 1);
  const pageSize = createMemo(() => options().params.pageSize ?? 10);
  const enabled = createMemo(() => options().config.enabled ?? true);
  const triggerInfinite = createMemo(() => options().config.infinite ?? false);
  const [queryClient] = createSignal(new QueryClient());
  const pagesCacheKey = createMemo(() => ({
    ...options().cacheKeys,
    ...options().params,
    initialPage: paginatedPage(),
    pageSize: pageSize()
  }));
  const query = createQuery(
    () => ({
      queryKey: [pagesCacheKey()],
      queryFn: ({ queryKey: [cacheKeyParams] }) => {
        const requestParams = getDifferentKeys(cacheKeyParams, cacheKeys);
        return fetcher?.(requestParams);
      },
      enabled: !triggerInfinite() && !!options().fetcher && enabled
    }),
    queryClient
  );
  const infiniteQueryKey = createMemo(() => ({
    ...options().cacheKeys,
    ...options().params,
    pageSize: pageSize()
  }));
  const infiniteQuery = createInfiniteQuery(
    () => ({
      queryKey: [infiniteQueryKey()],
      queryFn: ({ pageParam, queryKey: [cacheKeyParams] }) => {
        const requestParams = getDifferentKeys(
          {
            initialPage: initialPage() + pageParam,
            ...cacheKeyParams
          },
          // @ts-ignore
          cacheKeys
        );
        return fetcher?.(requestParams);
      },
      initialPageParam: initialPage(),
      getNextPageParam: (lastPage) => {
        if (lastPage && !lastPage.length) {
          return null;
        }
      },
      enabled: triggerInfinite() && enabled
    }),
    queryClient
  );
  const page = createMemo(() => {
    if (triggerInfinite()) {
      return infiniteQuery.data?.pages.length ?? 0;
    }
    return paginatedPage();
  });
  const data = createMemo(() => {
    if (triggerInfinite()) {
      return infiniteQuery.data?.pages.flat() ?? [];
    }
    return query.data?.data ?? [];
  });
  const count = createMemo(() => {
    if (triggerInfinite()) {
      return infiniteQuery.data?.pages?.[infiniteQuery.data?.pages.length - 1]?.total_count || 0;
    }
    return query.data?.total_count ?? 0;
  });
  const isLoading = createMemo(
    () => triggerInfinite() ? infiniteQuery.isLoading : query.isLoading
  );
  const isFetching = createMemo(
    () => triggerInfinite() ? infiniteQuery.isFetching : query.isFetching
  );
  const error = createMemo(
    () => triggerInfinite() ? infiniteQuery.error : query.error
  );
  const isError = createMemo(() => !!error());
  const fetchNext = () => {
    if (triggerInfinite()) {
      void infiniteQuery.fetchNextPage();
      return;
    }
    return setPaginatedPage((n) => n + 1);
  };
  const fetchPrevious = () => {
    if (triggerInfinite()) {
      void infiniteQuery.fetchPreviousPage();
      return;
    }
    return setPaginatedPage((n) => n - 1);
  };
  const offsetCount = createMemo(() => (initialPage() - 1) * pageSize());
  const pageCount = createMemo(
    () => Math.ceil((count() - offsetCount()) / pageSize())
  );
  const hasNextPage = createMemo(
    () => count() - offsetCount() * pageSize() > page() * pageSize()
  );
  const hasPreviousPage = createMemo(
    () => (page() - 1) * pageSize() > offsetCount() * pageSize()
  );
  const setData = triggerInfinite() ? (value) => queryClient().setQueryData([infiniteQueryKey], value) : (value) => queryClient().setQueryData([pagesCacheKey()], value);
  const revalidate = triggerInfinite() ? () => infiniteQuery.refetch() : () => query.refetch();
  return {
    data,
    count,
    error,
    isLoading,
    isFetching,
    isError,
    page,
    pageCount,
    fetchNext,
    fetchPrevious,
    hasNextPage,
    hasPreviousPage,
    // Let the hook return type define this type
    setData,
    // Let the hook return type define this type
    revalidate
  };
};

// src/hooks/use-organization.ts
var useOrganization = (params) => {
  useAssertWrappedByClerkProvider("useOrganization");
  const organization = useOrganizationContext();
  const session = useSessionContext();
  const domainSafeValues = createMemo(
    () => convertToSafeValues(params?.().domains, {
      initialPage: 1,
      pageSize: 10,
      keepPreviousData: false,
      infinite: false,
      enrollmentMode: undefined
    })
  );
  const membershipRequestSafeValues = createMemo(
    () => convertToSafeValues(params?.().membershipRequests, {
      initialPage: 1,
      pageSize: 10,
      status: "pending",
      keepPreviousData: false,
      infinite: false
    })
  );
  const membersSafeValues = createMemo(
    () => convertToSafeValues(params?.().memberships, {
      initialPage: 1,
      pageSize: 10,
      role: undefined,
      keepPreviousData: false,
      infinite: false
    })
  );
  const invitationsSafeValues = createMemo(
    () => convertToSafeValues(params?.().invitations, {
      initialPage: 1,
      pageSize: 10,
      status: ["pending"],
      keepPreviousData: false,
      infinite: false
    })
  );
  const clerk = useClerkInstanceContext();
  createEffect(() => {
    clerk().telemetry?.record(eventMethodCalled("useOrganization"));
  });
  const domainParams = createMemo(
    () => typeof params?.().domains === "undefined" ? undefined : {
      initialPage: domainSafeValues().initialPage,
      pageSize: domainSafeValues().pageSize,
      enrollmentMode: domainSafeValues().enrollmentMode
    }
  );
  const membershipRequestParams = createMemo(
    () => typeof params?.().membershipRequests === "undefined" ? undefined : {
      initialPage: membershipRequestSafeValues().initialPage,
      pageSize: membershipRequestSafeValues().pageSize,
      status: membershipRequestSafeValues().status
    }
  );
  const membersParams = createMemo(
    () => typeof params?.().memberships === "undefined" ? undefined : {
      initialPage: membersSafeValues().initialPage,
      pageSize: membersSafeValues().pageSize,
      role: membersSafeValues().role
    }
  );
  const invitationsParams = createMemo(
    () => typeof params?.().invitations === "undefined" ? undefined : {
      initialPage: invitationsSafeValues().initialPage,
      pageSize: invitationsSafeValues().pageSize,
      status: invitationsSafeValues().status
    }
  );
  const domains = usePagesOrInfinite(() => ({
    params: {
      ...domainParams()
    },
    fetcher: organization()?.getDomains,
    config: {
      keepPreviousData: domainSafeValues().keepPreviousData,
      infinite: domainSafeValues().infinite,
      enabled: !!domainParams()
    },
    cacheKeys: {
      type: "domains",
      organizationId: organization()?.id
    }
  }));
  const membershipRequests = usePagesOrInfinite(() => ({
    params: {
      ...membershipRequestParams()
    },
    fetcher: organization()?.getMembershipRequests,
    config: {
      keepPreviousData: membershipRequestSafeValues().keepPreviousData,
      infinite: membershipRequestSafeValues().infinite,
      enabled: !!membershipRequestParams()
    },
    cacheKeys: {
      type: "membershipRequests",
      organizationId: organization()?.id
    }
  }));
  const memberships = usePagesOrInfinite(() => ({
    params: membersParams() || {},
    fetcher: organization()?.getMemberships,
    config: {
      keepPreviousData: membersSafeValues().keepPreviousData,
      infinite: membersSafeValues().infinite,
      enabled: !!membersParams()
    },
    cacheKeys: {
      type: "members",
      organizationId: organization()?.id
    }
  }));
  const invitations = usePagesOrInfinite(() => ({
    params: {
      ...invitationsParams()
    },
    fetcher: organization()?.getInvitations,
    config: {
      keepPreviousData: invitationsSafeValues().keepPreviousData,
      infinite: invitationsSafeValues().infinite,
      enabled: !!invitationsParams()
    },
    cacheKeys: {
      type: "invitations",
      organizationId: organization()?.id
    }
  }));
  const isLoaded = createMemo(() => organization() === undefined);
  return {
    isLoaded,
    organization,
    membership: createMemo(() => {
      if (isLoaded()) {
        if (organization()) {
          return getCurrentOrganizationMembership(
            session().user.organizationMemberships,
            organization().id
          );
        } else {
          return null;
        }
      }
      return undefined;
    }),
    domains: createMemo(() => {
      if (isLoaded()) {
        if (organization()) {
          return domains;
        } else {
          return null;
        }
      }
      return undefined;
    }),
    membershipRequests: createMemo(() => {
      if (isLoaded()) {
        if (organization()) {
          return membershipRequests;
        } else {
          return null;
        }
      }
      return undefined;
    }),
    memberships: createMemo(() => {
      if (isLoaded()) {
        if (organization()) {
          return memberships;
        } else {
          return null;
        }
      }
      return undefined;
    }),
    invitations: createMemo(() => {
      if (isLoaded()) {
        if (organization()) {
          return invitations;
        } else {
          return null;
        }
      }
      return undefined;
    })
  };
};
function getCurrentOrganizationMembership(organizationMemberships, activeOrganizationId) {
  return organizationMemberships.find(
    (organizationMembership) => organizationMembership.organization.id === activeOrganizationId
  );
}
var useOrganizationList = (params) => {
  useAssertWrappedByClerkProvider("useOrganizationList");
  const userMembershipsSafeValues = createMemo(
    () => convertToSafeValues(params?.().userMemberships, {
      initialPage: 1,
      pageSize: 10,
      keepPreviousData: false,
      infinite: false
    })
  );
  const userInvitationsSafeValues = createMemo(
    () => convertToSafeValues(params?.().userInvitations, {
      initialPage: 1,
      pageSize: 10,
      status: "pending",
      keepPreviousData: false,
      infinite: false
    })
  );
  const userSuggestionsSafeValues = createMemo(
    () => convertToSafeValues(params?.().userSuggestions, {
      initialPage: 1,
      pageSize: 10,
      status: "pending",
      keepPreviousData: false,
      infinite: false
    })
  );
  const clerk = useClerkInstanceContext();
  const user = useUserContext();
  createEffect(() => {
    clerk().telemetry?.record(eventMethodCalled("useOrganizationList"));
  });
  const userMembershipsParams = createMemo(
    () => typeof params?.().userMemberships === "undefined" ? undefined : {
      initialPage: userMembershipsSafeValues().initialPage,
      pageSize: userMembershipsSafeValues().pageSize
    }
  );
  const userInvitationsParams = createMemo(
    () => typeof params?.().userInvitations === "undefined" ? undefined : {
      initialPage: userInvitationsSafeValues().initialPage,
      pageSize: userInvitationsSafeValues().pageSize,
      status: userInvitationsSafeValues().status
    }
  );
  const userSuggestionsParams = createMemo(
    () => typeof params?.().userSuggestions === "undefined" ? undefined : {
      initialPage: userSuggestionsSafeValues().initialPage,
      pageSize: userSuggestionsSafeValues().pageSize,
      status: userSuggestionsSafeValues().status
    }
  );
  const isClerkLoaded = createMemo(() => !!(clerk().loaded && user()));
  const memberships = usePagesOrInfinite(() => ({
    params: userMembershipsParams() || {},
    fetcher: user()?.getOrganizationMemberships,
    config: {
      keepPreviousData: userMembershipsSafeValues().keepPreviousData,
      infinite: userMembershipsSafeValues().infinite,
      enabled: !!userMembershipsParams()
    },
    cacheKeys: {
      type: "userMemberships",
      userId: user()?.id
    }
  }));
  const invitations = usePagesOrInfinite(() => ({
    params: {
      ...userInvitationsParams()
    },
    fetcher: user()?.getOrganizationInvitations,
    config: {
      keepPreviousData: userInvitationsSafeValues().keepPreviousData,
      infinite: userInvitationsSafeValues().infinite,
      enabled: !!userInvitationsParams()
    },
    cacheKeys: {
      type: "userInvitations",
      userId: user()?.id
    }
  }));
  const suggestions = usePagesOrInfinite(() => ({
    params: {
      ...userSuggestionsParams()
    },
    fetcher: user()?.getOrganizationSuggestions,
    config: {
      keepPreviousData: userSuggestionsSafeValues().keepPreviousData,
      infinite: userSuggestionsSafeValues().infinite,
      enabled: !!userSuggestionsParams()
    },
    cacheKeys: {
      type: "userSuggestions",
      userId: user()?.id
    }
  }));
  const createOrganization = (params2) => {
    return clerk().createOrganization(params2);
  };
  const setActive = (params2) => {
    return clerk().setActive(params2);
  };
  return {
    isLoaded: isClerkLoaded,
    createOrganization,
    setActive,
    userMemberships: createMemo(
      () => isClerkLoaded() ? memberships : undefined
    ),
    userInvitations: createMemo(
      () => isClerkLoaded() ? invitations : undefined
    ),
    userSuggestions: createMemo(
      () => isClerkLoaded() ? suggestions : undefined
    )
  };
};
var useSession = () => {
  useAssertWrappedByClerkProvider("useSession");
  const session = useSessionContext();
  const isLoaded = createMemo(() => session() !== undefined);
  const isSignedIn = createMemo(() => session() !== null);
  return {
    isLoaded,
    isSignedIn,
    session
  };
};
var useSessionList = () => {
  useAssertWrappedByClerkProvider("useSessionList");
  const isomorphicClerk = useClerkInstanceContext();
  const client = useClientContext();
  const isLoaded = createMemo(() => !!client());
  const sessions = createMemo(() => client()?.sessions);
  const setActive = (params) => {
    return isomorphicClerk()?.setActive(params);
  };
  return {
    isLoaded,
    sessions,
    setActive
  };
};
var useSignIn = () => {
  useAssertWrappedByClerkProvider("useSignIn");
  const isomorphicClerk = useIsomorphicClerkContext();
  const client = useClientContext();
  createEffect(() => {
    isomorphicClerk().telemetry?.record(eventMethodCalled("useSignIn"));
  });
  const isLoaded = createMemo(() => !!client());
  const signIn = createMemo(() => client()?.signIn);
  const setActive = (params) => {
    return isomorphicClerk()?.setActive(params);
  };
  return {
    isLoaded,
    signIn,
    setActive
  };
};
var useSignUp = () => {
  useAssertWrappedByClerkProvider("useSignUp");
  const isomorphicClerk = useIsomorphicClerkContext();
  const client = useClientContext();
  createEffect(() => {
    isomorphicClerk().telemetry?.record(eventMethodCalled("useSignUp"));
  });
  const isLoaded = createMemo(() => !!client());
  const signUp = createMemo(() => client()?.signUp);
  const setActive = (params) => {
    return isomorphicClerk()?.setActive(params);
  };
  return {
    isLoaded,
    signUp,
    setActive
  };
};
function useUser() {
  useAssertWrappedByClerkProvider("useUser");
  const user = useUserContext();
  const isLoaded = createMemo(() => user() !== undefined);
  const isSignedIn = createMemo(() => user() !== null);
  return {
    isLoaded,
    isSignedIn,
    user
  };
}

// src/index.tsx
setErrorThrowerOptions({
  packageName: "clerk-solidjs"
});

export { AuthenticateWithRedirectCallback, ClerkLoaded, ClerkLoading, CreateOrganization, GoogleOneTap, OrganizationList, OrganizationProfile, OrganizationSwitcher, Protect, RedirectToCreateOrganization, RedirectToOrganizationProfile, RedirectToSignIn, RedirectToSignUp, RedirectToUserProfile, SignIn, SignInButton, SignInWithMetamaskButton, SignOutButton, SignUp, SignUpButton, SignedIn, SignedOut, UserButton, UserProfile, useAuth, useClerk, useEmailLink, useOrganization, useOrganizationList, useSession, useSessionList, useSignIn, useSignUp, useUser };
