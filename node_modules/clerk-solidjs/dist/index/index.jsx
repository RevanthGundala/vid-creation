import {
  ClerkInstanceContext,
  ClerkProvider,
  assertSingleChild,
  errorThrower,
  normalizeWithDefaultValue,
  organizationProfileLinkRenderedError,
  organizationProfilePageRenderedError,
  safeExecute,
  setErrorThrowerOptions,
  useAuthContext,
  useAuthHasRequiresRoleOrPermission,
  useClerkInstanceContext,
  useClientContext,
  useIsomorphicClerkContext,
  useOrganizationContext,
  useSessionContext,
  useUserContext,
  userProfileLinkRenderedError,
  userProfilePageRenderedError
} from "../chunk/7ARPN5DO.jsx";

// src/polyfills.ts
if (typeof window !== "undefined" && !window.global) {
  window.global = typeof global === "undefined" ? window : global;
}

// src/components/control-components.tsx
import {
  createEffect as createEffect2,
  createMemo as createMemo2,
  Match,
  Show as Show2,
  splitProps,
  Switch
} from "solid-js";

// src/hooks/use-assert-wrapped-by-clerk-provider.tsx
import { useContext } from "solid-js";
function useAssertWrappedByClerkProvider(displayNameOrFn) {
  const ctx = useContext(ClerkInstanceContext);
  if (!ctx) {
    if (typeof displayNameOrFn === "function") {
      displayNameOrFn();
      return;
    }
    throw new Error(
      `${displayNameOrFn} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider`
    );
  }
}

// src/hooks/use-auth.ts
import { createMemo } from "solid-js";

// src/hooks/utils.ts
var clerkLoaded = (isomorphicClerk) => {
  return new Promise((resolve) => {
    const clerk = isomorphicClerk();
    if (clerk.loaded) {
      resolve();
    }
    clerk.addOnLoaded(resolve);
  });
};
var createGetToken = (isomorphicClerk) => {
  return async (options) => {
    const clerk = isomorphicClerk();
    await clerkLoaded(isomorphicClerk);
    if (!clerk.session) {
      return null;
    }
    return clerk.session.getToken(options);
  };
};
var createSignOut = (isomorphicClerk) => {
  return async (...args) => {
    await clerkLoaded(isomorphicClerk);
    return isomorphicClerk().signOut(...args);
  };
};

// src/hooks/use-auth.ts
var useAuth = () => {
  useAssertWrappedByClerkProvider("useAuth");
  const { sessionId, userId, actor, orgId, orgRole, orgPermissions } = useAuthContext();
  const isomorphicClerk = useIsomorphicClerkContext();
  const getToken = createGetToken(isomorphicClerk);
  const signOut = createSignOut(isomorphicClerk);
  const has = (params) => {
    if (!params?.permission && !params?.role) {
      errorThrower.throw(useAuthHasRequiresRoleOrPermission);
    }
    if (!orgId() || !userId() || !orgRole() || !orgPermissions()) {
      return false;
    }
    if (params.permission) {
      return orgPermissions().includes(params.permission);
    }
    if (params.role) {
      return orgRole() === params.role;
    }
    return false;
  };
  const isLoaded = createMemo(
    () => sessionId() !== void 0 && userId() !== void 0
  );
  const isSignedIn = createMemo(() => {
    if (!isLoaded()) {
      return void 0;
    }
    return sessionId() !== null && userId() !== null;
  });
  return {
    isLoaded,
    isSignedIn,
    sessionId,
    userId,
    actor,
    orgId,
    orgRole,
    orgPermissions,
    has,
    signOut,
    getToken
  };
};

// src/components/with-clerk.tsx
import { createEffect, Show } from "solid-js";
var withClerk = (Component3, displayName) => {
  displayName = displayName || Component3.name || "Component";
  return (props) => {
    useAssertWrappedByClerkProvider(displayName || "withClerk");
    const clerk = useIsomorphicClerkContext();
    const isLoaded = () => clerk().loaded;
    return <Show when={isLoaded()}>
        <Component3 {...props} clerk={clerk} />
      </Show>;
  };
};

// src/components/control-components.tsx
var SignedIn = (props) => {
  useAssertWrappedByClerkProvider("SignedIn");
  const { userId } = useAuthContext();
  return <Show2 when={userId()}>{props.children}</Show2>;
};
var SignedOut = (props) => {
  useAssertWrappedByClerkProvider("SignedOut");
  const { userId } = useAuthContext();
  return <Show2 when={userId() === null}>{props.children}</Show2>;
};
var ClerkLoaded = (props) => {
  useAssertWrappedByClerkProvider("ClerkLoaded");
  const isomorphicClerk = useIsomorphicClerkContext();
  const isLoaded = () => isomorphicClerk().loaded;
  return <Show2 when={isLoaded()}>{props.children}</Show2>;
};
var ClerkLoading = (props) => {
  useAssertWrappedByClerkProvider("ClerkLoading");
  const isomorphicClerk = useIsomorphicClerkContext();
  const isLoaded = () => isomorphicClerk().loaded;
  return <Show2 when={!isLoaded()}>{props.children}</Show2>;
};
var Protect = (props) => {
  useAssertWrappedByClerkProvider("Protect");
  const [local, restAuthorizedParams] = splitProps(props, [
    "children",
    "fallback"
  ]);
  const { isLoaded, has, userId } = useAuth();
  const unauthorized = <>{local.fallback ?? null}</>;
  const authorized = <>{local.children}</>;
  return <Switch fallback={unauthorized}>
      <Match when={!isLoaded()}>{unauthorized}</Match>
      <Match when={!userId()}>{unauthorized}</Match>
      <Match
    when={typeof restAuthorizedParams.condition === "function" && restAuthorizedParams.condition(has)}
  >
        {authorized}
      </Match>
      <Match
    when={(restAuthorizedParams.role || restAuthorizedParams.permission) && has(restAuthorizedParams)}
  >
        {authorized}
      </Match>
    </Switch>;
};
var RedirectToSignIn = withClerk(
  (props) => {
    const [local, redirectToSignInProps] = splitProps(props, ["clerk"]);
    const hasActiveSessions = createMemo2(
      () => local.clerk().client.activeSessions && local.clerk().client.activeSessions.length > 0
    );
    createEffect2(() => {
      if (local.clerk().session === null && hasActiveSessions()) {
        void local.clerk().redirectToAfterSignOut();
      } else {
        void local.clerk().redirectToSignIn(redirectToSignInProps);
      }
    });
    return null;
  },
  "RedirectToSignIn"
);
var RedirectToSignUp = withClerk(
  (props) => {
    const [local, redirectToSignUpProps] = splitProps(props, ["clerk"]);
    createEffect2(() => {
      void local.clerk().redirectToSignUp(redirectToSignUpProps);
    });
    return null;
  },
  "RedirectToSignUp"
);
var RedirectToUserProfile = withClerk((props) => {
  createEffect2(() => {
    void props.clerk().redirectToUserProfile();
  });
  return null;
}, "RedirectToUserProfile");
var RedirectToOrganizationProfile = withClerk((props) => {
  createEffect2(() => {
    void props.clerk().redirectToOrganizationProfile();
  });
  return null;
}, "RedirectToOrganizationProfile");
var RedirectToCreateOrganization = withClerk((props) => {
  createEffect2(() => {
    void props.clerk().redirectToCreateOrganization();
  });
  return null;
}, "RedirectToCreateOrganization");
var AuthenticateWithRedirectCallback = withClerk(
  (props) => {
    const [local, handleRedirectCallbackParams] = splitProps(props, ["clerk"]);
    createEffect2(() => {
      void local.clerk().handleRedirectCallback(handleRedirectCallbackParams);
    });
    return null;
  },
  "AuthenticateWithRedirectCallback"
);

// src/components/sign-in-button.tsx
import { children as childrenFn, createMemo as createMemo3, splitProps as splitProps2 } from "solid-js";
var SignInButton = withClerk(
  (props) => {
    const [local, clerkProps, rest] = splitProps2(
      props,
      ["children"],
      [
        "clerk",
        "signUpFallbackRedirectUrl",
        "signUpForceRedirectUrl",
        "forceRedirectUrl",
        "fallbackRedirectUrl",
        "mode",
        "onClick"
      ]
    );
    const children2 = childrenFn(
      () => normalizeWithDefaultValue(local.children, "Sign in")
    );
    const child = createMemo3(
      () => assertSingleChild(children2())("SignInButton")
    );
    const clickHandler = async () => {
      const { onClick, mode, clerk, ...opts } = clerkProps;
      if (onClick) {
        await safeExecute(onClick)();
      }
      if (mode === "modal") {
        return clerk().openSignIn(opts);
      }
      return clerk().redirectToSignIn({
        ...opts,
        signInFallbackRedirectUrl: clerkProps.fallbackRedirectUrl,
        signInForceRedirectUrl: clerkProps.forceRedirectUrl
      });
    };
    return <button {...rest} onClick={clickHandler}>
        {child()}
      </button>;
  },
  "SignInButton"
);

// src/components/sign-in-with-metamask-button.tsx
import { children as childrenFn2, createMemo as createMemo4, splitProps as splitProps3 } from "solid-js";
var SignInWithMetamaskButton = withClerk(
  (props) => {
    const [local, clerkProps, rest] = splitProps3(
      props,
      ["children"],
      ["clerk", "redirectUrl", "onClick"]
    );
    const children2 = childrenFn2(
      () => normalizeWithDefaultValue(local.children, "Sign in with Metamask")
    );
    const child = createMemo4(
      () => assertSingleChild(children2())("SignInWithMetamaskButton")
    );
    const clickHandler = async () => {
      const { onClick, clerk, ...opts } = clerkProps;
      if (onClick) {
        await safeExecute(onClick)();
      }
      async function authenticate() {
        await clerk().authenticateWithMetamask({
          ...opts,
          redirectUrl: opts.redirectUrl || void 0
        });
      }
      void authenticate();
    };
    return <button {...rest} onClick={clickHandler}>
        {child()}
      </button>;
  },
  "SignInWithMetamask"
);

// src/components/sign-out-button.tsx
import { children as childrenFn3, createMemo as createMemo5, splitProps as splitProps4 } from "solid-js";
var SignOutButton = withClerk(
  (props) => {
    const [local, clerk, rest] = splitProps4(
      props,
      ["children"],
      ["clerk", "redirectUrl", "sessionId", "onClick"]
    );
    const children2 = childrenFn3(
      () => normalizeWithDefaultValue(local.children, "Sign out")
    );
    const child = createMemo5(
      () => assertSingleChild(children2())("SignOutButton")
    );
    const clickHandler = async () => {
      if (clerk.onClick) {
        await safeExecute(clerk.onClick)();
      }
      clerk.clerk().signOut({
        redirectUrl: clerk.redirectUrl,
        sessionId: clerk.sessionId
      });
    };
    return <button {...rest} onClick={clickHandler}>
        {child()}
      </button>;
  },
  "SignOutButton"
);

// src/components/sign-up-button.tsx
import { children as childrenFn4, createMemo as createMemo6, splitProps as splitProps5 } from "solid-js";
var SignUpButton = withClerk(
  (props) => {
    const [local, clerkProps, rest] = splitProps5(
      props,
      ["children"],
      ["clerk", "mode", "fallbackRedirectUrl", "forceRedirectUrl", "onClick"]
    );
    const children2 = childrenFn4(
      () => normalizeWithDefaultValue(local.children, "Sign up")
    );
    const child = createMemo6(
      () => assertSingleChild(children2())("SignUpButton")
    );
    const clickHandler = async () => {
      const { onClick, mode, clerk, ...opts } = clerkProps;
      if (onClick) {
        await safeExecute(clerkProps.onClick)();
      }
      if (mode === "modal") {
        return clerk().openSignUp(opts);
      }
      return clerk().redirectToSignUp({
        ...opts,
        signUpFallbackRedirectUrl: clerkProps.fallbackRedirectUrl,
        signUpForceRedirectUrl: clerkProps.forceRedirectUrl
      });
    };
    return <button {...rest} onClick={clickHandler}>
        {child()}
      </button>;
  },
  "SignUpButton"
);

// src/components/ui-components.tsx
import { logErrorInDevMode } from "@clerk/shared";
import {
  children,
  createEffect as createEffect3,
  createSignal,
  onCleanup,
  onMount,
  splitProps as splitProps6
} from "solid-js";
var isMountProps = (props) => {
  return "mount" in props;
};
var isOpenProps = (props) => {
  return "open" in props;
};
var Portal = (props) => {
  const [portalRef, setPortalRef] = createSignal();
  const componentProps = () => props.props;
  createEffect3(() => {
    const ref = portalRef();
    if (ref && isMountProps(props)) {
      props.updateProps({
        node: ref,
        props: componentProps()
      });
    }
  });
  onMount(() => {
    const ref = portalRef();
    if (ref) {
      if (isMountProps(props)) {
        props.mount(ref, componentProps());
      } else if (isOpenProps(props)) {
        props.open(componentProps());
      }
    }
  });
  onCleanup(() => {
    const ref = portalRef();
    if (ref) {
      if (isMountProps(props)) {
        props.unmount(ref);
      } else if (isOpenProps(props)) {
        props.close();
      }
    }
  });
  return <div ref={setPortalRef} />;
};
var SignIn = withClerk((props) => {
  const [local, rest] = splitProps6(props, ["clerk"]);
  return <Portal
    mount={local.clerk().mountSignIn}
    unmount={local.clerk().unmountSignIn}
    updateProps={local.clerk().__unstable__updateProps}
    props={rest}
  />;
}, "SignIn");
var SignUp = withClerk((props) => {
  const [local, rest] = splitProps6(props, ["clerk"]);
  return <Portal
    mount={local.clerk().mountSignUp}
    unmount={local.clerk().unmountSignUp}
    updateProps={local.clerk().__unstable__updateProps}
    props={rest}
  />;
}, "SignUp");
function UserProfilePage(props) {
  logErrorInDevMode(userProfilePageRenderedError);
  return children(() => props.children);
}
function UserProfileLink(props) {
  logErrorInDevMode(userProfileLinkRenderedError);
  return children(() => props.children);
}
var _UserProfile = withClerk(
  (props) => {
    const [local, rest] = splitProps6(props, ["clerk"]);
    return <Portal
      mount={local.clerk().mountUserProfile}
      unmount={local.clerk().unmountUserProfile}
      updateProps={local.clerk().__unstable__updateProps}
      props={rest}
    />;
  },
  "UserProfile"
);
var UserProfile = Object.assign(_UserProfile, {
  Page: UserProfilePage,
  Link: UserProfileLink
});
var _UserButton = withClerk(
  (props) => {
    const [local, rest] = splitProps6(props, ["clerk"]);
    return <Portal
      mount={local.clerk().mountUserButton}
      unmount={local.clerk().unmountUserButton}
      updateProps={local.clerk().__unstable__updateProps}
      props={rest}
    />;
  },
  "UserButton"
);
var UserButton = Object.assign(_UserButton, {
  UserProfilePage,
  UserProfileLink
});
function OrganizationProfilePage(props) {
  logErrorInDevMode(organizationProfilePageRenderedError);
  return children(() => props.children);
}
function OrganizationProfileLink(props) {
  logErrorInDevMode(organizationProfileLinkRenderedError);
  return children(() => props.children);
}
var _OrganizationProfile = withClerk(
  (props) => {
    const [local, rest] = splitProps6(props, ["clerk"]);
    return <Portal
      mount={local.clerk().mountOrganizationProfile}
      unmount={local.clerk().unmountOrganizationProfile}
      updateProps={local.clerk().__unstable__updateProps}
      props={rest}
    />;
  },
  "OrganizationProfile"
);
var OrganizationProfile = Object.assign(
  _OrganizationProfile,
  {
    Page: OrganizationProfilePage,
    Link: OrganizationProfileLink
  }
);
var CreateOrganization = withClerk(
  (props) => {
    const [local, rest] = splitProps6(props, ["clerk"]);
    return <Portal
      mount={local.clerk().mountCreateOrganization}
      unmount={local.clerk().unmountCreateOrganization}
      updateProps={local.clerk().__unstable__updateProps}
      props={rest}
    />;
  },
  "CreateOrganization"
);
var _OrganizationSwitcher = withClerk(
  (props) => {
    const [local, rest] = splitProps6(props, ["clerk"]);
    return <Portal
      mount={local.clerk().mountOrganizationSwitcher}
      unmount={local.clerk().unmountOrganizationSwitcher}
      updateProps={local.clerk().__unstable__updateProps}
      props={rest}
    />;
  },
  "OrganizationSwitcher"
);
var OrganizationSwitcher = Object.assign(_OrganizationSwitcher, {
  OrganizationProfilePage,
  OrganizationProfileLink
});
var OrganizationList = withClerk(
  (props) => {
    const [local, rest] = splitProps6(props, ["clerk"]);
    return <Portal
      mount={local.clerk().mountOrganizationList}
      unmount={local.clerk().unmountOrganizationList}
      updateProps={local.clerk().__unstable__updateProps}
      props={rest}
    />;
  },
  "OrganizationList"
);
var GoogleOneTap = withClerk(
  (props) => {
    const [local, rest] = splitProps6(props, ["clerk"]);
    return <Portal
      open={local.clerk().openGoogleOneTap}
      close={local.clerk().closeGoogleOneTap}
      props={rest}
    />;
  },
  "GoogleOneTap"
);

// src/hooks/use-clerk.ts
var useClerk = () => {
  useAssertWrappedByClerkProvider("useClerk");
  return useClerkInstanceContext();
};

// src/hooks/use-email-link.ts
import { destructure } from "@solid-primitives/destructure";
import { createEffect as createEffect4, createMemo as createMemo7, onCleanup as onCleanup2 } from "solid-js";
function useEmailLink(resource) {
  const linkFlows = createMemo7(() => resource().createEmailLinkFlow());
  createEffect4(() => {
    onCleanup2(linkFlows().cancelEmailLinkFlow);
  });
  return destructure(linkFlows);
}

// src/hooks/use-organization.ts
import { eventMethodCalled } from "@clerk/shared/telemetry";
import { createEffect as createEffect5, createMemo as createMemo9 } from "solid-js";

// src/hooks/use-pages-or-infinite.ts
import { createWritableMemo } from "@solid-primitives/memo";
import {
  createInfiniteQuery,
  createQuery,
  QueryClient
} from "@tanstack/solid-query";
import { createMemo as createMemo8, createSignal as createSignal2 } from "solid-js";
function getDifferentKeys(obj1, obj2) {
  const keysSet = new Set(Object.keys(obj2));
  const differentKeysObject = {};
  for (const key1 of Object.keys(obj1)) {
    if (!keysSet.has(key1)) {
      differentKeysObject[key1] = obj1[key1];
    }
  }
  return differentKeysObject;
}
var convertToSafeValues = (params, defaultValues) => {
  const shouldUseDefaults = typeof params === "boolean" && params;
  const initialPageRef = shouldUseDefaults ? defaultValues.initialPage : params?.initialPage ?? defaultValues.initialPage;
  const pageSizeRef = shouldUseDefaults ? defaultValues.pageSize : params?.pageSize ?? defaultValues.pageSize;
  const newObj = {};
  for (const key of Object.keys(defaultValues)) {
    newObj[key] = shouldUseDefaults ? (
      // @ts-ignore
      defaultValues[key]
    ) : (
      // @ts-ignore
      params?.[key] ?? defaultValues[key]
    );
  }
  return {
    ...newObj,
    initialPage: initialPageRef,
    pageSize: pageSizeRef
  };
};
var usePagesOrInfinite = (options) => {
  const [paginatedPage, setPaginatedPage] = createWritableMemo(
    () => options().params.initialPage ?? 1
  );
  const initialPage = createMemo8(() => options().params.initialPage ?? 1);
  const pageSize = createMemo8(() => options().params.pageSize ?? 10);
  const enabled = createMemo8(() => options().config.enabled ?? true);
  const triggerInfinite = createMemo8(() => options().config.infinite ?? false);
  const [queryClient] = createSignal2(new QueryClient());
  const pagesCacheKey = createMemo8(() => ({
    ...options().cacheKeys,
    ...options().params,
    initialPage: paginatedPage(),
    pageSize: pageSize()
  }));
  const query = createQuery(
    () => ({
      queryKey: [pagesCacheKey()],
      queryFn: ({ queryKey: [cacheKeyParams] }) => {
        const requestParams = getDifferentKeys(cacheKeyParams, cacheKeys);
        return fetcher?.(requestParams);
      },
      enabled: !triggerInfinite() && !!options().fetcher && enabled
    }),
    queryClient
  );
  const infiniteQueryKey = createMemo8(() => ({
    ...options().cacheKeys,
    ...options().params,
    pageSize: pageSize()
  }));
  const infiniteQuery = createInfiniteQuery(
    () => ({
      queryKey: [infiniteQueryKey()],
      queryFn: ({ pageParam, queryKey: [cacheKeyParams] }) => {
        const requestParams = getDifferentKeys(
          {
            initialPage: initialPage() + pageParam,
            ...cacheKeyParams
          },
          // @ts-ignore
          cacheKeys
        );
        return fetcher?.(requestParams);
      },
      initialPageParam: initialPage(),
      getNextPageParam: (lastPage) => {
        if (lastPage && !lastPage.length) {
          return null;
        }
      },
      enabled: triggerInfinite() && enabled
    }),
    queryClient
  );
  const page = createMemo8(() => {
    if (triggerInfinite()) {
      return infiniteQuery.data?.pages.length ?? 0;
    }
    return paginatedPage();
  });
  const data = createMemo8(() => {
    if (triggerInfinite()) {
      return infiniteQuery.data?.pages.flat() ?? [];
    }
    return query.data?.data ?? [];
  });
  const count = createMemo8(() => {
    if (triggerInfinite()) {
      return infiniteQuery.data?.pages?.[infiniteQuery.data?.pages.length - 1]?.total_count || 0;
    }
    return query.data?.total_count ?? 0;
  });
  const isLoading = createMemo8(
    () => triggerInfinite() ? infiniteQuery.isLoading : query.isLoading
  );
  const isFetching = createMemo8(
    () => triggerInfinite() ? infiniteQuery.isFetching : query.isFetching
  );
  const error = createMemo8(
    () => triggerInfinite() ? infiniteQuery.error : query.error
  );
  const isError = createMemo8(() => !!error());
  const fetchNext = () => {
    if (triggerInfinite()) {
      void infiniteQuery.fetchNextPage();
      return;
    }
    return setPaginatedPage((n) => n + 1);
  };
  const fetchPrevious = () => {
    if (triggerInfinite()) {
      void infiniteQuery.fetchPreviousPage();
      return;
    }
    return setPaginatedPage((n) => n - 1);
  };
  const offsetCount = createMemo8(() => (initialPage() - 1) * pageSize());
  const pageCount = createMemo8(
    () => Math.ceil((count() - offsetCount()) / pageSize())
  );
  const hasNextPage = createMemo8(
    () => count() - offsetCount() * pageSize() > page() * pageSize()
  );
  const hasPreviousPage = createMemo8(
    () => (page() - 1) * pageSize() > offsetCount() * pageSize()
  );
  const setData = triggerInfinite() ? (value) => queryClient().setQueryData([infiniteQueryKey], value) : (value) => queryClient().setQueryData([pagesCacheKey()], value);
  const revalidate = triggerInfinite() ? () => infiniteQuery.refetch() : () => query.refetch();
  return {
    data,
    count,
    error,
    isLoading,
    isFetching,
    isError,
    page,
    pageCount,
    fetchNext,
    fetchPrevious,
    hasNextPage,
    hasPreviousPage,
    // Let the hook return type define this type
    setData,
    // Let the hook return type define this type
    revalidate
  };
};

// src/hooks/use-organization.ts
var useOrganization = (params) => {
  useAssertWrappedByClerkProvider("useOrganization");
  const organization = useOrganizationContext();
  const session = useSessionContext();
  const domainSafeValues = createMemo9(
    () => convertToSafeValues(params?.().domains, {
      initialPage: 1,
      pageSize: 10,
      keepPreviousData: false,
      infinite: false,
      enrollmentMode: void 0
    })
  );
  const membershipRequestSafeValues = createMemo9(
    () => convertToSafeValues(params?.().membershipRequests, {
      initialPage: 1,
      pageSize: 10,
      status: "pending",
      keepPreviousData: false,
      infinite: false
    })
  );
  const membersSafeValues = createMemo9(
    () => convertToSafeValues(params?.().memberships, {
      initialPage: 1,
      pageSize: 10,
      role: void 0,
      keepPreviousData: false,
      infinite: false
    })
  );
  const invitationsSafeValues = createMemo9(
    () => convertToSafeValues(params?.().invitations, {
      initialPage: 1,
      pageSize: 10,
      status: ["pending"],
      keepPreviousData: false,
      infinite: false
    })
  );
  const clerk = useClerkInstanceContext();
  createEffect5(() => {
    clerk().telemetry?.record(eventMethodCalled("useOrganization"));
  });
  const domainParams = createMemo9(
    () => typeof params?.().domains === "undefined" ? void 0 : {
      initialPage: domainSafeValues().initialPage,
      pageSize: domainSafeValues().pageSize,
      enrollmentMode: domainSafeValues().enrollmentMode
    }
  );
  const membershipRequestParams = createMemo9(
    () => typeof params?.().membershipRequests === "undefined" ? void 0 : {
      initialPage: membershipRequestSafeValues().initialPage,
      pageSize: membershipRequestSafeValues().pageSize,
      status: membershipRequestSafeValues().status
    }
  );
  const membersParams = createMemo9(
    () => typeof params?.().memberships === "undefined" ? void 0 : {
      initialPage: membersSafeValues().initialPage,
      pageSize: membersSafeValues().pageSize,
      role: membersSafeValues().role
    }
  );
  const invitationsParams = createMemo9(
    () => typeof params?.().invitations === "undefined" ? void 0 : {
      initialPage: invitationsSafeValues().initialPage,
      pageSize: invitationsSafeValues().pageSize,
      status: invitationsSafeValues().status
    }
  );
  const domains = usePagesOrInfinite(() => ({
    params: {
      ...domainParams()
    },
    fetcher: organization()?.getDomains,
    config: {
      keepPreviousData: domainSafeValues().keepPreviousData,
      infinite: domainSafeValues().infinite,
      enabled: !!domainParams()
    },
    cacheKeys: {
      type: "domains",
      organizationId: organization()?.id
    }
  }));
  const membershipRequests = usePagesOrInfinite(() => ({
    params: {
      ...membershipRequestParams()
    },
    fetcher: organization()?.getMembershipRequests,
    config: {
      keepPreviousData: membershipRequestSafeValues().keepPreviousData,
      infinite: membershipRequestSafeValues().infinite,
      enabled: !!membershipRequestParams()
    },
    cacheKeys: {
      type: "membershipRequests",
      organizationId: organization()?.id
    }
  }));
  const memberships = usePagesOrInfinite(() => ({
    params: membersParams() || {},
    fetcher: organization()?.getMemberships,
    config: {
      keepPreviousData: membersSafeValues().keepPreviousData,
      infinite: membersSafeValues().infinite,
      enabled: !!membersParams()
    },
    cacheKeys: {
      type: "members",
      organizationId: organization()?.id
    }
  }));
  const invitations = usePagesOrInfinite(() => ({
    params: {
      ...invitationsParams()
    },
    fetcher: organization()?.getInvitations,
    config: {
      keepPreviousData: invitationsSafeValues().keepPreviousData,
      infinite: invitationsSafeValues().infinite,
      enabled: !!invitationsParams()
    },
    cacheKeys: {
      type: "invitations",
      organizationId: organization()?.id
    }
  }));
  const isLoaded = createMemo9(() => organization() === void 0);
  return {
    isLoaded,
    organization,
    membership: createMemo9(() => {
      if (isLoaded()) {
        if (organization()) {
          return getCurrentOrganizationMembership(
            session().user.organizationMemberships,
            organization().id
          );
        } else {
          return null;
        }
      }
      return void 0;
    }),
    domains: createMemo9(() => {
      if (isLoaded()) {
        if (organization()) {
          return domains;
        } else {
          return null;
        }
      }
      return void 0;
    }),
    membershipRequests: createMemo9(() => {
      if (isLoaded()) {
        if (organization()) {
          return membershipRequests;
        } else {
          return null;
        }
      }
      return void 0;
    }),
    memberships: createMemo9(() => {
      if (isLoaded()) {
        if (organization()) {
          return memberships;
        } else {
          return null;
        }
      }
      return void 0;
    }),
    invitations: createMemo9(() => {
      if (isLoaded()) {
        if (organization()) {
          return invitations;
        } else {
          return null;
        }
      }
      return void 0;
    })
  };
};
function getCurrentOrganizationMembership(organizationMemberships, activeOrganizationId) {
  return organizationMemberships.find(
    (organizationMembership) => organizationMembership.organization.id === activeOrganizationId
  );
}

// src/hooks/use-organization-list.ts
import { eventMethodCalled as eventMethodCalled2 } from "@clerk/shared/telemetry";
import { createEffect as createEffect6, createMemo as createMemo10 } from "solid-js";
var useOrganizationList = (params) => {
  useAssertWrappedByClerkProvider("useOrganizationList");
  const userMembershipsSafeValues = createMemo10(
    () => convertToSafeValues(params?.().userMemberships, {
      initialPage: 1,
      pageSize: 10,
      keepPreviousData: false,
      infinite: false
    })
  );
  const userInvitationsSafeValues = createMemo10(
    () => convertToSafeValues(params?.().userInvitations, {
      initialPage: 1,
      pageSize: 10,
      status: "pending",
      keepPreviousData: false,
      infinite: false
    })
  );
  const userSuggestionsSafeValues = createMemo10(
    () => convertToSafeValues(params?.().userSuggestions, {
      initialPage: 1,
      pageSize: 10,
      status: "pending",
      keepPreviousData: false,
      infinite: false
    })
  );
  const clerk = useClerkInstanceContext();
  const user = useUserContext();
  createEffect6(() => {
    clerk().telemetry?.record(eventMethodCalled2("useOrganizationList"));
  });
  const userMembershipsParams = createMemo10(
    () => typeof params?.().userMemberships === "undefined" ? void 0 : {
      initialPage: userMembershipsSafeValues().initialPage,
      pageSize: userMembershipsSafeValues().pageSize
    }
  );
  const userInvitationsParams = createMemo10(
    () => typeof params?.().userInvitations === "undefined" ? void 0 : {
      initialPage: userInvitationsSafeValues().initialPage,
      pageSize: userInvitationsSafeValues().pageSize,
      status: userInvitationsSafeValues().status
    }
  );
  const userSuggestionsParams = createMemo10(
    () => typeof params?.().userSuggestions === "undefined" ? void 0 : {
      initialPage: userSuggestionsSafeValues().initialPage,
      pageSize: userSuggestionsSafeValues().pageSize,
      status: userSuggestionsSafeValues().status
    }
  );
  const isClerkLoaded = createMemo10(() => !!(clerk().loaded && user()));
  const memberships = usePagesOrInfinite(() => ({
    params: userMembershipsParams() || {},
    fetcher: user()?.getOrganizationMemberships,
    config: {
      keepPreviousData: userMembershipsSafeValues().keepPreviousData,
      infinite: userMembershipsSafeValues().infinite,
      enabled: !!userMembershipsParams()
    },
    cacheKeys: {
      type: "userMemberships",
      userId: user()?.id
    }
  }));
  const invitations = usePagesOrInfinite(() => ({
    params: {
      ...userInvitationsParams()
    },
    fetcher: user()?.getOrganizationInvitations,
    config: {
      keepPreviousData: userInvitationsSafeValues().keepPreviousData,
      infinite: userInvitationsSafeValues().infinite,
      enabled: !!userInvitationsParams()
    },
    cacheKeys: {
      type: "userInvitations",
      userId: user()?.id
    }
  }));
  const suggestions = usePagesOrInfinite(() => ({
    params: {
      ...userSuggestionsParams()
    },
    fetcher: user()?.getOrganizationSuggestions,
    config: {
      keepPreviousData: userSuggestionsSafeValues().keepPreviousData,
      infinite: userSuggestionsSafeValues().infinite,
      enabled: !!userSuggestionsParams()
    },
    cacheKeys: {
      type: "userSuggestions",
      userId: user()?.id
    }
  }));
  const createOrganization = (params2) => {
    return clerk().createOrganization(params2);
  };
  const setActive = (params2) => {
    return clerk().setActive(params2);
  };
  return {
    isLoaded: isClerkLoaded,
    createOrganization,
    setActive,
    userMemberships: createMemo10(
      () => isClerkLoaded() ? memberships : void 0
    ),
    userInvitations: createMemo10(
      () => isClerkLoaded() ? invitations : void 0
    ),
    userSuggestions: createMemo10(
      () => isClerkLoaded() ? suggestions : void 0
    )
  };
};

// src/hooks/use-session.ts
import { createMemo as createMemo11 } from "solid-js";
var useSession = () => {
  useAssertWrappedByClerkProvider("useSession");
  const session = useSessionContext();
  const isLoaded = createMemo11(() => session() !== void 0);
  const isSignedIn = createMemo11(() => session() !== null);
  return {
    isLoaded,
    isSignedIn,
    session
  };
};

// src/hooks/use-session-list.ts
import { createMemo as createMemo12 } from "solid-js";
var useSessionList = () => {
  useAssertWrappedByClerkProvider("useSessionList");
  const isomorphicClerk = useClerkInstanceContext();
  const client = useClientContext();
  const isLoaded = createMemo12(() => !!client());
  const sessions = createMemo12(() => client()?.sessions);
  const setActive = (params) => {
    return isomorphicClerk()?.setActive(params);
  };
  return {
    isLoaded,
    sessions,
    setActive
  };
};

// src/hooks/use-sign-in.ts
import { eventMethodCalled as eventMethodCalled3 } from "@clerk/shared/telemetry";
import { createEffect as createEffect7, createMemo as createMemo13 } from "solid-js";
var useSignIn = () => {
  useAssertWrappedByClerkProvider("useSignIn");
  const isomorphicClerk = useIsomorphicClerkContext();
  const client = useClientContext();
  createEffect7(() => {
    isomorphicClerk().telemetry?.record(eventMethodCalled3("useSignIn"));
  });
  const isLoaded = createMemo13(() => !!client());
  const signIn = createMemo13(() => client()?.signIn);
  const setActive = (params) => {
    return isomorphicClerk()?.setActive(params);
  };
  return {
    isLoaded,
    signIn,
    setActive
  };
};

// src/hooks/use-sign-up.ts
import { eventMethodCalled as eventMethodCalled4 } from "@clerk/shared/telemetry";
import { createEffect as createEffect8, createMemo as createMemo14 } from "solid-js";
var useSignUp = () => {
  useAssertWrappedByClerkProvider("useSignUp");
  const isomorphicClerk = useIsomorphicClerkContext();
  const client = useClientContext();
  createEffect8(() => {
    isomorphicClerk().telemetry?.record(eventMethodCalled4("useSignUp"));
  });
  const isLoaded = createMemo14(() => !!client());
  const signUp = createMemo14(() => client()?.signUp);
  const setActive = (params) => {
    return isomorphicClerk()?.setActive(params);
  };
  return {
    isLoaded,
    signUp,
    setActive
  };
};

// src/hooks/use-user.ts
import { createMemo as createMemo15 } from "solid-js";
function useUser() {
  useAssertWrappedByClerkProvider("useUser");
  const user = useUserContext();
  const isLoaded = createMemo15(() => user() !== void 0);
  const isSignedIn = createMemo15(() => user() !== null);
  return {
    isLoaded,
    isSignedIn,
    user
  };
}

// src/index.tsx
setErrorThrowerOptions({ packageName: "clerk-solidjs" });
export {
  AuthenticateWithRedirectCallback,
  ClerkLoaded,
  ClerkLoading,
  ClerkProvider,
  CreateOrganization,
  GoogleOneTap,
  OrganizationList,
  OrganizationProfile,
  OrganizationSwitcher,
  Protect,
  RedirectToCreateOrganization,
  RedirectToOrganizationProfile,
  RedirectToSignIn,
  RedirectToSignUp,
  RedirectToUserProfile,
  SignIn,
  SignInButton,
  SignInWithMetamaskButton,
  SignOutButton,
  SignUp,
  SignUpButton,
  SignedIn,
  SignedOut,
  UserButton,
  UserProfile,
  useAuth,
  useClerk,
  useEmailLink,
  useOrganization,
  useOrganizationList,
  useSession,
  useSessionList,
  useSignIn,
  useSignUp,
  useUser
};
